《两数之和》是很经典的一道数组类型算法题，在我学习过程中也遇到好多次，本道题是两数之和的基础题，后续还有变种。


# 解法一：暴力破解 ⭐⭐
💖思考方式：
当我第一次看到这道题，我可以很轻易的想到，两次遍历去找到结果，也就是“暴力破解法”。当然如果遇到算法题第一次没有想到暴力破解，也不要伤心，算法是一个厚积薄发的过程，量变引起质变，所以没关系的。跑题了，继续哈。暴力破解具体如何做呢？


过程推理：
预定义：外循环指针i，内循环指针j，给定值target，给定数组arr
初始化：i=0，j=i+1，len=arr.length-1
step1：外循环i∈[0，len] , 内循环j∈[i+1,len]，判断arr[i]+arr[j]=target? 如果满足则返回i，j 。
step2：如果不满足上述条件，那么继续循环，直到循环完成，因为问题定义肯定有解，所以在循环结束前一定可以找到满足条件的值。


💖解题图示：
![leetcode专用.mp4](bd4903af-76d5-4975-93c9-e5d4b9aa6ac3)


💖实现代码：
```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int i = 0;
        int j = 1;
        int len = nums.length-1;
        for(int i=0;i<=len;i++){
            for(int j=i+1;j<=len;j++){
                if(nums[i]+nums[j]==target){
                    return new int[]{i,j};
                }
            }
        }
    }
}
```


💖效率分析：
其实如果我们写的算法多了，就会不自觉的想要降低时间复杂度和空间复杂度，时间复杂度对应程序的运行时间，也叫做延迟时间或者响应时间，空间复杂度对应硬件资源。在实际开发中，这两者没有重要级的优先，而是同样重要。所以我们写完算法一定要分析自己的代码效率。低效的代码写出来可能在实际应用环境中也无法运行。所以我们的目标是算法运行时间更短、消耗资源更少、自己更满意。
时间复杂度：因为外部和内部嵌套两次循环，所以可以轻易得出是O(n^2).
空间复杂度：计算过程中，除了返回结果所消耗的空间只开辟了常数级别的对象，所以可以得出是O(1).


💖对比大佬：
哈哈🤣果然暴力破解算法是这样~~~
![image.png](https://pic.leetcode-cn.com/1627485895-nFxoCm-image.png)




## 解法二：空间换时间--哈希表存储 ⭐⭐⭐⭐

💖思考方式：
题目中要求寻找a和b，使得a+b满足target，也就是寻找数据关系。
1）使用暴力法寻找满足关系的时候只能一个一个元素去遍历，举例：前提在数组arr中，给一个a（a in arr），问有没有一个b和a加起来是target的？因为不了解数组中的元素，所以只能一个一个去寻找可能是b的每一个元素。 也就是，给你一个数组arr，问你arr中有没有5呀，你当然不知道了，只能一个一个去找了呗。
2）如果有一个容器，可以直接告诉你里面是否存在某个元素，是不是就快多了。举例：前提在容器vec中，给一个a（a in arr），问有没有一个b和a加起来是target的？因为了解容器中的每一个元素，所以直接找（target-a）是否存在vec中，vec直接就返回了是或否。这样就快多了。这样的容器其实有很多，比如set、map等等。
3）我们发现，vec存在b，我们找到答案了，我们要返回结果呀是不，所以我们如果使用set了，发现set里面只存储了元素，不对呀。返回结果不要元素，要下标呀，假如可以把下标和元素值一起存储就好了。。。。这个时候，map就用到了，map天然是k-v模式，恰好可以存储下标对应的值，如果值b符合a+b=target，那么直接返回值b的所对应的下标value即可。（为什么a的下标不用从map中返回呢？因为a此时是遍历的，遍历过程a的下标是被循环所记录的，直接返回当前循环体中的递增值i即可）
4）所以我们需要先把数组存储转化为map存储，然后在遍历数组中每一个元素a，寻找map中是否有匹配的元素b。


💖过程推理：
预定义：数组arr，映射容器map，循环体递增值i（a的下标）
step1：遍历arr，将arr的数组下标和下标所对应的值put到map中（这里要处理重复值，下文描述）
step2：i归0，遍历arr的元素a，去map中寻找b=（target-a）是否存在，如果存在，判断a和b的下标是不是同一个，如果是同一个是不可以返回的哦，因为题目说明了不能一个元素使用两次，如果下标不同的话就返回当前new int[]{i,b.index},如果不存在，继续执行step2


💖💖特殊点处理：
1）如果遇到map中有重复的值，那么需要将已存在重复值覆盖掉吗？
解：题目中是这样描述的：“你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现”，所以我们可以判断出如果在遍历的过程出现了重复元素，我们记作r，且有另外一个元素的值和r的值是一样的，我们记作r1，（两个元素在数组中的前后顺序这里不需要讨论,我们假设r是先存储在map中的元素，r1是后遍历到的元素）。我们判断是否可以覆盖或者不可以覆盖的根本标准是，覆盖了r会不会影响结果？如果返回里面没有r或者r1，那么覆盖了也不影响最后返回值，如果结果中存在r或者r1，那么覆盖就会影响结果，就不可以覆盖了~ 
如下判断是否影响结果：
①如果存在r+b = target，那么一定存在r1+b=target，存在了两个答案，所以此时与题意不符。也即是重复元素r不可以满足（r=a || r=b ） ，一旦满足就违背了题目要求。
②那么如果（r=a && r1=b）呢，如果存在r+r1=target，此时和题意符合。是可能的情况。
③也即是说，r若影响结果只有一种可能，那就是r+r1=target，除此之外，r的覆盖与否不影响算法正确性。
④所以，遇到重复值的时候，需要判断，如果r1+r2<>target，那么可以覆盖也可以不覆盖，看你心情；如果r1+r2=target，那么直接返回map中r1的下标和当前的r2循环位置即可，over。


💖实现代码：
```
class Solution {
    HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
            for(int i=0;i<nums.length;i++){
                if(map.containsKey(nums[i])){
                    if(nums[i]*2==target){
                        return new int[]{map.get(nums[i]),i};
                    }
                }
                map.put(nums[i],i);
            }
            for(int i=0;i<nums.length;i++){
                int b = target-nums[i];
                if(map.containsKey(b)){
                    if(i!=map.get(b)){
                        return new int[]{i,map.get(b)};
                    }
                }
            }
            return new int[]{0,0};
}
```


💖效率分析：
时间复杂度：O(n)【时间复杂度即代码运行的次数，因为我们初始化map的时候执行了n次，然后寻找a+b关系的时候也执行了n次，其余常数级运行次数不算。所以一共是2n次，只看最高幂，去掉系数项，时间复杂度是O(n)】
空间复杂度：O(n)【运行中为了减少查询数据关系的复杂度，增加了map结构，初始化了几个变量不计，本身的返回结果int[]不计，消耗了2n个单位用来存储map的值，n个元素值，n个下标值。所以空间复杂度是O(n)】


💖对比大佬：
我发现每次点击运行显示的效率都不太一样哈啊哈，可能是电脑网速或者其他啥的问题😝，时间上比暴力破解快多了，不过空间消耗多了点点😝
![image.png](https://pic.leetcode-cn.com/1627959792-zrPZoW-image.png)



## 解法三：哈希表存储优化⭐⭐⭐⭐⭐

💖思考方式：
哈希表的方法，确实快多了。但是我们遍历了两次arr，同样map的put了n次，get了n次。有什么方法可以减少我们的运行次数呢？
1）我们之所以选择遍历两次arr，是因为如果开始没有将全部元素都put到map中，那么在遍历a的时候，万一存在b满足a+b=target，但是因为此时b还没加载到map里面，导致没有及时返回正确，并a此时也遍历结束跳过了，岂不是凉凉哉。。。
2）😺我们来看下哈，方案1中确实会发生这样的现象，因为如果想要没有全部加载完元素就开始寻找答案，是有可能跳过a的，但是想一下，如果a被跳过了，a就不会返回了吗？当我们终于遍历到b的时候，map里面有a的呀！！！！那么此时b可以找到a搭伙满足a+b=target的。所以a还是会被返回的。
3）结论：可以一遍put元素一遍寻找答案，只要存在答案，那么一定会在arr遍历前被返回。因为返回的答案是组合，a和b，我们不仅可以拿着a去找b，也可以拿着b去找a。只要两个元素在同一个地方，那么不管中途是否错过，只要元素满足数据关系，最后一定会找到对的那个它。

💖过程推理：
预定义：数组arr，映射容器map，循环体递增值i（a的下标），temp设为变量(target-a)
step1：遍历arr，如果temp存在于map中，如果temp的下标和i的值不一样，直接返回答案
step2：如果temp不存在map中，那么将a插入到map结构中，插入的时候需要判断map中是否存在a，重复值判断逻辑及遇到重复值处理逻辑都和方法二一样；如果不存在将a插入，如果存在，判断a是否可以覆盖；
step3：循环执行step1和step2，直到返回结果

💖实现代码：
```
class Solution {
    public int[] twoSum(int[] nums, int target) {

        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(nums[i])){
                if(nums[i]*2==target){
                    return new int[]{map.get(nums[i]),i};
                }
            }
            int tmp = target - nums[i];
            if(map.containsKey(tmp)){
                return new int[]{i,map.get(tmp)};
            }else{
                map.put(nums[i],i);
            }
        }
        return new int[]{};
    }
}
```


💖效率分析:
时间复杂度：O(n)【时间复杂度即代码运行的次数，因为我们初始化map和寻找数据关系的时候一共执行了n次，其余常数级运行次数不算。所以一共是1n次，只看最高幂，去掉系数项，时间复杂度是O(n)】
空间复杂度：O(n)【运行中为了减少查询数据关系的复杂度，增加了map结构，初始化了几个变量不计，本身的返回结果int[]不计，消耗了2n个单位用来存储map的值，n个元素值，n个下标值。所以空间复杂度是O(n)】

对比大佬:
比第二种方法快多了哈~~但是还是有很多大神的写法，我赶紧去学习学习😝
![image.png](https://pic.leetcode-cn.com/1627963355-gtMwiy-image.png)



2021-08-03 12:03  完更
请多鼓励，谢谢大家❤️❤️❤️❤️❤️~~~

🙌🙌🙌🙌
结语：对于每个人来讲，在leetcode上进行探索以及单人闯关是一件有趣的时间，一个程序员，如果不喜欢编程，那么可能就失去了这份职业的乐趣。刷到我的文章的人，我希望你们可以驻足一小会，忙里偷闲的阅读一下我的文章，可能文章的内容对你来说很简单，(*^▽^*)不过文章中的每一个字都是我认真专注的见证！希望您看完之后，若是能帮到您，劳烦请您简单动动手指鼓励我，我必回报更大的付出~
